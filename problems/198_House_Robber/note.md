## 問題
あなたは通り沿いの家での強盗を計画しているプロの合同である。
それぞれの家は特定の額のお金を隠している。
それらの家のそれぞれから強盗ができなくなる唯一の制約は、
隣り合った家がつながったセキュリティシステムを持っており、
もし2つの隣り合った家が同じ夜に侵入されたら警察に自動的に連絡される。

それぞれの家のお金の額を示す整数配列`nums`が与えられたとき、
警察に通報されずに今夜強盗できる額の合計の最大値を返せ。

## 解法
### 1. DP
```cpp
int rob(vector<int> &nums)
{
	vector<int> dp(nums.size() + 1, 0);
	dp[0] = 0;
	dp[1] = nums[0];

	for (int i = 2; i < dp.size(); ++i)
	{
		dp[i] = max(nums[i - 1] + dp[i - 2], dp[i - 1]);
	}

	return dp.back();
}
```
`dp[i]`には、`nums`の`[0,i)`の範囲の部分配列で盗んだ場合の
最大値が入る。
`dp`の更新は、
「2つ前まででの部分配列での最大値と現在の家の合計」と「1つ前の部分配列での最大値」のうち
大きい方を取ることで行う。
