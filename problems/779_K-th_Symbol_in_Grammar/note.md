## 問題
（1から始めて）`n`行のテーブルを構築する。
`1`番目の行に`0`を書くところから始める。
以降、各行では前の行を見てそれぞれの`0`の出現を`01`で置き換え、
`1`の出現を`10`で置き換える。

例えば、`n=3`のとき、`1`番目の行は`0`、`2`番目は`01`、`3`番目は`0110`。

2つの整数`n`と`k`が与えられたとき、
`n`行のテーブルの`n`番目の行の（1から数えて）`k`番目のシンボルを返せ。

## 解法
### 1. 数列の法則を利用した再帰
```cpp
int kthGrammar(int n, int k)
{
	if (k == 1)
		return 0;
	if (k == 2)
		return 1;

	int mid = pow(2, n - 2);
	if (mid < k)
	{
		return kthGrammar(n - 1, k - mid) ? 0 : 1;
	}
	return kthGrammar(n - 1, k);
}
```
数列を並べてみるとその法則性が見える。
`0`
`01`
`0110`
`01101001`
`0110100110010110`
数列の前半は、前回の数列と全く同じ。
数列の後半は、前回の数列の反転。
これを利用して、再帰的に解く。

### 2. 二分探索
```cpp
int kthGrammar(int n, int k)
{
	int l = 1;
	int r = pow(2, n - 1);
	int cur = 0;

	while (l < r)
	{
		int mid = (l + r) / 2;
		if (mid < k)
		{
			l = mid + 1;
			cur = 1 - cur;
		}
		else
		{
			r = mid;
		}
	}

	return cur;
}
```
数列を以下のような二分木で考える。
- 0のノードからは、左に0、右に1が伸びる。
- 1のノードからは、左に1、右に0が伸びる。
この木を探索していき、
同じ高さのノードを左から数えて`k`番目（1始まり）となるノードの値が答えとなる。

左に行くときはノードの値が変わらず、
右に行くときはノードの値が変わる性質がある。
