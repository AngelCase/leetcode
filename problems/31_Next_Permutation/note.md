## 問題
整数配列の順列とは
その要素をシーケンスあるいは線形順序に並び替えることである。

例えば、`arr = [1,2,3]`があったとき、以下は全ての`arr`の順列である。
`[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]`

配列の次の順列とは次の辞書式順序的に大きい順列である。
さらに正式には、もし配列の全ての順列を辞書式順序で単一のコンテナ内でソートしたら、
その配列の次の順列はソートされたコンテナで後続するものとなる。
もしそのような並び替えが不可能ならば、
配列は可能な限り小さい順序で再配置する必要がある（つまり昇順ソート）。

- 例えば、`arr = [1,2,3]`の次の順列は`[1,3,2]`。
- 同様に、`arr = [2,3,1]`の次の順列は`[3,1,2]`。
- 一方、`arr = [3,2,1]`の次の順列は`[1,2,3]`となる。なぜなら`[3,2,1]`は辞書的により大きい再配置を持たないため。

整数配列`nums`が与えられたとき、`num`の次の順列を探せ。

再配置はその場で行い、
定数の追加メモリのみを使うこと。

## 閃き
順列を並べてみても解に至るのは難しく、
アルゴリズムを覚えるのが一番早い。

右から順に見ていって、
「最後の順列」でない部分配列か確認していく。
「途中の順列」だったら、左端を次の順列で左端に来る要素と入れ替えて、
「最初の順列」となるようひっくり返せば次の順列が得られる。
```c
例：
[1,2,4,3]なら[2,4,3]は「最後」じゃない。
↓
[2,4,3]の次を作るなら、左端は3であるべき。
↓
[3,4,2]として、[4,2]をひっくり返す。
↓
[1,3,2,4]
```

## 解法
### 1. std::next_permutation
```cpp
void nextPermutation(vector<int> &nums)
{
	if (next_permutation(nums.begin(), nums.end()))
	{
		return;
	}

	sort(nums.begin(), nums.end());
}
```
`std::next_permutation`を使い、次の順列を作れたら終了、
作れなかったら最初に戻るのでソートして終了。

### 2. 
```cpp
void nextPermutation(vector<int> &nums)
{
	for (int i = nums.size() - 2; 0 <= i; --i)
	{
		// 右から順番に桁を増やしながら見ていき、
		// 「最後の順列」ではない場所を探す
		if (nums[i] < nums[i + 1])
		{
			// ピボットより大きく、かつ最小を探す
			// 右から順に大きくなるので右から見ればよい
			int swapIdx = nums.size() - 1;
			while (nums[swapIdx] <= nums[i])
			{
				swapIdx--;
			}

			// ピボットと発見した数字を入れ替え
			swap(nums[i], nums[swapIdx]);

			// 「右から順に大きくなる」という性質は維持されている
			// だから反転すれば「最初の順列」が得られる
			reverse(nums.begin() + (i + 1), nums.end());

			return;
		}
	}

	reverse(nums.begin(), nums.end());
}
```
右から部分配列を広げながら見ていき、
その部分配列が「最後の順列」でなくなるタイミングを探す。
```c
（例）
配列：[1,3,4,3,2]
[3,2]     → 最後の順列
[4,3,2]   → 最後の順列
[3,4,3,2] → 最後の順列ではない
```

「最後の順列」でなくなったときに追加された要素をピボットと呼ぶ。

部分配列から、ピボットより大きい中で最も小さい要素を探し、ピボットと入れ替える。
すると、この部分配列は「最後の順列」になる。
```c
（例）
ピボット：3
部分配列：[4,3,2]
3より大きい要素のうち最小は4なので入れ替えると
4 [3,3,2]
```

この順序をひっくり返すと「最初の順列」が得られる。
他の部分配列とくっつければ、次の順列が得られる。
```c
（例）
[3,3,2] → [2,3,3]
1,4 [3,3,2]
答え：[1,4,2,3,3]
```
