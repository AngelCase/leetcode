## 問題
昇順にソートされた長さ`n`の配列が`1`から`n`回回転していると仮定する。
例えば、配列`nums = [0,1,2,4,5,6,7]`は次のようになる：
- もし`4`回回転したら`[4,5,6,7,0,1,2]`
- もし`7`回回転したら`[0,1,2,4,5,6,7]`

配列`[a[0], a[1], a[2], ..., a[n-1]]`を1回回転させた結果は
配列`[a[n-1], a[0], a[1], a[2], ..., a[n-2]]`となる。

ユニークな要素を持つソートされ回転された配列`nums`が与えられたとき、
この配列の最小要素を返せ。

アルゴリズムは$O(log_n)$で動くように書け。

## 解法
### 1. 二分探索
```cpp
int findMin(vector<int> &nums)
{
	int min = 5000;
	int start = 0;
	int last = nums.size() - 1;

	while (1)
	{
		int mid = (start + last) / 2;
		min = std::min(min, nums[mid]);
		if (last <= start)
		{
			break;
		}
		if (nums[mid] < nums[last])
		{
			last = mid - 1;
			continue;
		}
		start = mid + 1;
	}
	return min;
}
```
「どこで数字が下がるか？」を二分探索で探す。
そうすれば、数字が下がるところに最小値がある。

中央の値と末尾の値を比較したとき、
- 末尾の方が大きいなら、左半分で数字が下がっている。
- 末尾の方が小さいなら、右半分で数字が下がっている。
これをもとに、配列を分割し、最小値を記録していけば
効率的に最小値を探せる。

## 学び
